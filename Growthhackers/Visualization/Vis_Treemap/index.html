

<!DOCTYPE html>
<html lang="kr">

<head>
    <meta charset="utf-8">
    <title>D3 페이지 템플릿</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style>
    </style>
</head>

<body>
    
    <script>
    d3.json('flare.json').then(callback);
    function callback(data) {
        console.log(data);
        var hierarchy = d3.hierarchy(data, function (d) { return d.children });
        console.log(hierarchy);
    
    hierarchy.sum(function (d) { return d.size }) //size를 합하여 value를 계산 (비고) function(d) { return 1; 자식노드 개수}
            .sort(function (a, b) { return b.height - a.height || b.value - a.value; })
    console.log(hierarchy);
    

    var w = 600, h = 400;
        var margin = { top: 40, right: 10, bottom: 10, left: 10 };
        var innerW = w - margin.right - margin.left,
            innerH = h - margin.top - margin.bottom;

        var svg = d3.select('body').append('svg')
            .attr('width', w)
            .attr('height', h)
            .append('g')
            .attr('transform', 'translate(' + [margin.left, margin.top] + ')');
     
            var opacityDomain = d3.extent(hierarchy.leaves(), function (d) { return d.value; }); // 말단 노드의 value값의 범위를 가져온다.
            var opacity = d3.scaleLinear().domain(opacityDomain).range([0.4, 1.0]);

            var colorDomain = hierarchy.children.map(function (d) { return d.data.name }); // 깊이가 1인 노드들의 이름을 가져온다.
            var color = d3.scaleOrdinal().domain(colorDomain).range(d3.schemeCategory10);
     
        var treemap = d3.treemap() //treemap을 위한 데이터 구조를 생성하는 generator
                .size([innerW, innerH])
            //.tile(d3.treemapSquarify)
            hierarchy = treemap(hierarchy); 
            var nodes = hierarchy.descendants();
            console.log(nodes)
        var leaf = svg.selectAll('.leaf')
                .data(nodes.filter(function (n) { return !n.children }), function (d) { return d.data.name }) //filter를 통해서 children이 없는 말단 노드만 선택
                .enter().append('rect')
                .attr('class', 'leaf')
                .attr('x', function (d) { return d.x0 })
                .attr('y', function (d) { return d.y0 })
                .attr('width', function (d) { return d.x1 - d.x0 })
                .attr('height', function (d) { return d.y1 - d.y0 })
                .style('fill-opacity', function (d) { return opacity(d.value) });
                
        function findParent(node, depth) { //특정 depth 값을 갖는 부모를 찾는다.
                if (node.depth < depth) {
                    return null;
                } else if (node.depth === depth) {
                    return node;
                }
                if (node.parent) {
                    return findParent(node.parent, depth); //재귀 recursion
                }
            }

            leaf.style('fill', function (d) { return color(findParent(d, 1).data.name) });
    }
    
    function node(selection, d) { // 데이터 d는 현재 레벨에 해당하는 노드들이 배열 형태로 들어온다.
            var el = selection.selectAll('.node')
                .data(d, function (d) { return d.data.name; });  // 현재 레벨에서 추가가능한 데이터를 추가한다. 
            el.enter().append('g')
                .attr('class', 'node')
               .each(function (d) {
                        if (d.children) {
                            d3.select(this).call(parent) // parent 함수를 call
                               // .call(node, d.children);
                        } else {
                            d3.select(this).call(leaf); //leaf 함수를 call
                        }
                    })
                

            
            return selection;
        }

        function leaf(selection) {
                selection.classed('leaf', true)
                    .append('rect')
                    .attr('x', function (d) { return d.x0 })
                    .attr('y', function (d) { return d.y0 })
                    .attr('width', function (d) { return d.x1 - d.x0 })
                    .attr('height', function (d) { return d.y1 - d.y0 })
                    .style('fill', function (d) { return color(findParent(d, 1).data.name) })
                    .style('fill-opacity', function (d) { return opacity(d.value) });
                return selection;
            }

            function parent(selection) {
                    selection.classed('parent', true);
                    selection.append('rect')
                        .attr('width', function (d) { return d.x1 - d.x0; })
                        .attr('height', function (d) { return paddingTop; })
                        .attr('x', function (d) { return d.x0; })
                        .attr('y', function (d) { return d.y0; })
                        .style('fill', '#eee')
                        .style('stroke', '#ddd')
                        .style('cursor', 'pointer');
                    selection.append('text') // 이름 적어주기
                        .text(function (d) { return d.data.name })
                        .attr('dy', function (d) { return '1em' })
                        .attr('x', function (d) { return d.x0; })
                        .attr('y', function (d) { return d.y0; })
                        .style('font-size', '12px')
                        .style('font-family', 'sans-serif')
                        .style('pointer-events', 'none');
                    return selection;

                    selection.select('rect').on('mouseenter', function (d) {
                    d3.event.stopPropagation(); //부모로 이벤트 전달 막음
                    d3.select(this.parentNode).selectAll('.leaf > rect')
                        .style('fill', 'lemonchiffon');
                }).on('mouseleave', function (d) {
                    d3.event.stopPropagation();
                    d3.select(this.parentNode).selectAll('.leaf > rect')
                        .style('fill', function (d) { return color(findParent(d, 1).data.name) });
                })
            }
                
/*
             var paddingTop = 16;
                var treemap = d3.treemap()
                    .size([innerW, innerH])
                    .paddingTop(paddingTop);

                hierarchy = treemap(hierarchy);
                //console.log(hierarchy)
                svg.call(node, [hierarchy]);   
    }
*/
    </script>
</body>

</html>